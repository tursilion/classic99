
! COPY this file to a empty DISK 2 or 3, named "BATCH"  then type:
! CALL USER("DSK1.BATCH")

! Print out a copy to follow
! along with the program

! PRESS ANY KEY
CALL KEY("",5,K,S)
NEW
! As you can see RXB KEY 
! has been modified to 
! accept empty strings

! PRESS ANY KEY
CALL KEY("",5,K,S)
NEW
CALL QUITON

! To follow along with this  
! demo print it out first
! Demo creates XB programs

! PRESS ANY KEY TO CONTINUE

! PRESS QUIT TO EXIT USER

CALL KEY("",5,K,S)
NEW
! RXB CALL KEY UPDATED

! Normal XB split keyboard
CALL KEY(1,A,X) :: CALL KEY(2,B,Y)

! RXB UPDATE split keyboard
CALL KEY(1,A,X,2,B,Y)

! See no double Colon needed 
! or RXB saves typing

! (HINT: press space bar)
CALL KEY(" ",5,K,S)
NEW
! RXB ADDS A STRING CHECK

! (HINT: press Y N y n)

CALL KEY("YyNn",5,K,S)

! (HINT: press a number)

CALL KEY("1234567890",5,K,S)

! (HINT: press ENTER)

CALL KEY(CHR$(13),5,K,S)

! (HINT: press a symbol)

V$="`~!@#$%^&*()-_=+[]\{}|"

CALL KEY(V$,5,K,S)

! Much less XB code in RXB 
! than in normal XB to do
! same thing

CALL KEY("",5,K,S)
NEW
100 ! Normal XB CALL KEY      routine vs RXBONKEY
110 CALL CLEAR
120 PRINT "XB CHOOSE A KEY:":"Yes, No, Maybe, End"
130 CALL KEY(3,K,S)
140 IF K=89 THEN PRINT "YES" :: GOTO 130
150 IF K=78 THEN PRINT "NO" :: GOTO 130
160 IF K=77 THEN PRINT "MAYBE" :: GOTO 130
170 IF K=69 THEN PRINT "END" :: GOTO 190
180 GOTO 130
190 ! RXB  CALL ONKEY routine
200 ! RXB CALL ONKEY
210 CALL CLEAR
220 PRINT "RXB CHOOSE A KEY:":"Yes, No, Maybe, End"
230 CALL ONKEY("YNME",3,K,S)GOTO 250,260,280,280
240 GOTO 230
250 PRINT "Yes!" :: GOTO 230
260 PRINT "Nn!" :: GOTO 230
270 PRINT "Maybe" :: GOTO 230
280 PRINT "End!"

SAVE DSK1.RXBONKEY,IV254
NEW 
! RXB can save files in     Internal Format on most XB  programs but the catch i
s   must be over 288 bytes in   size thus converted to IV254
! XB program are normally   Program Image format so can be confused with normall
y   Assembly Language Program   files
! RXB fixed this so you can save programs in Internal   Variable 254 format
CALL KEY("",5,K,S)
NEW
! This is done by how you   save those programs         EXAMPLE:
! SAVE DSK1.PRGMNAME,IV254
! See the comma and IV254?

CALL KEY("",5,K,S)
NEW
! RXB can save most files inINTERNAL VARIABLE 254 formatinstead of PROGRAM forma
t
! RXB makes cataloging filesbetter for you to use as    PROGRAM format is confus
ed  with Assembly Programs often, so  RXB fixed this!
! Tack a comma and IV254 to change from XB Program      Image to IV254 format
! EXAMPLE:                  SAVE "DSK1.IV-Format",IV254

CALL KEY("",5,K,S)
NEW
! See above comma and IV254 this is an added RXB option
! Now if the XB program is  smaller then 2 sectors it   will be saved in program
    image format instead the    reason is 254 filler bytes  waste space

CALL KEY("",5,K,S)
NEW
1 ! MERGE TO SHOW ADDRESS     AND LINE SIZE OF PROGRAMS
2 CALL CLEAR :: PRINT:"Output to Device? (Y/N)" :: CALL KEY("YN",3,K,S) :: IF K=
89 THEN INPUT "DEVICE:":Z$ :: OPEN #1:Z$,OUTPUT :: P=1
3 CALL CLEAR :: CALL PEEK(-31952,A,B,C,D) :: A=A*256+B-65536 :: C=C*256+D-65536 
:: PRINT #P:"    PROGRAM INFORMATION": :"Line Number Table" :: CALL HEX(A,A$,C,C
$)
4 PRINT #P: :"Start Address ";A$:"End   Address ";C$: : :"Line    Bytes Start":"
Number  Used  Address":"------  ----- -------"
5 FOR I=C-3 TO A STEP-4 :: CALL PEEK(I,B,D,E,F) :: B=B*256+D :: E=E*256+F-65536 
:: CALL PEEK(E-1,D) :: D=D+5 :: T=T+D :: CALL HEX(E,E$)
6 PRINT #P,USING "#####     ###  ######":B,D,E$ :: IF E THEN CALL SCREEN(6) :: G
OSUB 8
7 NEXT I :: A=(A-C-1)/-4 :: PRINT #P: : :TAB(8);"Total Bytes =";T:"   Number of 
lines =";A:"Average Bytes/Line =";INT(T/A) :: STOP
8 IF Z$="" THEN CALL KEY("",3,D,E) :: CALL SCREEN(8) :: RETURN ELSE RETURN


SAVE "DSK1.LINESHOW",MERGE
CALL KEY("",5,K,S)
NEW
100 ! CHAR HAS BEEN MODIFIEDIN RXB TO REPEAT AFTER A    COMMA
110 CALL CHAR(65,"FF00FFEE00FF8899") :: CALL CHAR(66,"454567656895439")! NORMAL 
XB
120 !
130 CALL CHAR(65,"FF00FFEE00FF8899",66,"454567656895439")! RXB CALL CHAR
140 !
150 CALL CHAR(ALL,"FFEEDDCCBBAA0099")! RXB ADDED ALL

SAVE DSK1.CHAR,IV254
NEW
100 ! HCHAR RXB VERSION HAS ADDED A AUTOREPEAT AFTER A  COMMA
110 CALL HCHAR(3,4,44,4) :: CALL HCHAR(6,8,47,8) :: CALL HCHAR(11,14,53,9) :: CA
LL HCHAR(20,8,77,11)! XB VERSION
120 CALL HCHAR(3,4,44,4,6,8,47,8,11,14,53,9,20,8,77,11)! THIS IS RXB VERSION

SAVE DSK1.HCHAR,IV254
NEW
100 ! GHCAR RXB VERSION HAS ADDED A AUTOREPEAT AFTER A  COMMA
110 CALL GCHAR(3,4,A) :: CALL GCHAR(6,8,B) :: CALL GCHAR(11,14,C) :: CALL GCHAR(
20,8,D)! XB VERSION
120 CALL GCHAR(3,4,A,6,8,B,11,14,C,20,8,D)! RXB VERSION

SAVE DSK1.GCHAR,IV254
NEW
100 ! HEX IS A RXB DECIMAL  TO HEX CONVERTER FOR ADDRESSIN TI
110 ! SEE THE HEXDECBIN PGM
120 FOR D=-32767 TO 32767
130 CALL HEX(D,H$)
140 PRINT D,H$
150 NEXT D

SAVE DSK1.HEX,IV254
NEW
100 ! HPUT IS A RXB PROGRAM THAT TAKES A STRING VARIABLEAND PUTS IT ON THE SCREE
N
105 CALL CLEAR
110 CALL HCHAR(9,9,44,3,9,12,45,3,9,15,46,3,9,18,47,3) ! RXB HCHAR
120 X$=",,,---...///" :: CALL HPUT(3,9,X$) !      HPUT PUTS AT 3,9 X$ ON THE  SC
REEN
130 GOTO 130

SAVE DSK1.HPUT,IV254
NEW
100 ! HGET IS A RXB PROGRAM THAT GETS A STRING OFF THE  SCREEN AND PUTS IT INTO 
A   STRING VARIBLE
110 CALL GCHAR(3,9,A,3,10,B,3,11,C,3,12,D)! RXB GCHAR
120 CALL HGET(3,9,4,X$)!    HGET 4 CHARACTERS AT 3,9 ANDPUTS THEM INTO X$

SAVE DSK1.HGET,IV254
NEW
100 ! INIT IN RXB DOES NOT  HAVE TO BE USED BEFORE LINK OR LOAD
110 CALL INIT! FIXED INIT  AS IT LOADED TO MUCH UNUSED DATA IN LOWER 8K
120 ! ALSO THIS WAS NOTED   IN THE ORGINAL XB SOURCE    CODE I HAVE FROM TI

SAVE DSK1.INIT,IV254
NEW
100 ! PEEKG IS A RXB COMMANDFOR PEEKING GRAM/GROM
110 CALL PEEKG(24576,X)!   PEEK GRAM/GROM AT >6000

SAVE DSK1.PEEKG,IV254
NEW
100 ! PEEKV IS A RXB COMMANDFOR PEEKING VDP
110 FOR X=16370 TO 16383
120 CALL PEEKV(X,Y)! PEEK  VDP AT X AND PUT INTO Y
130 PRINT X,CHR$(Y);Y
140 NEXT X

SAVE DSK1.PEEKV,IV254
NEW
100 ! POKEG IS A RXB COMMANDFOR PUTTING VALUES INTO GRAM
120 CALL POKEG(-8,22)! PUT  22 >16 AT ADDRESS -8 >FFF8  IN GRAM

SAVE DSK1.POKEG,IV254
NEW
100 ! POKER IS A RXB COMMANDFOR PUTTING VALUES INTO THE VDP REGISTERS 0 TO 7
110 CALL POKER(7,244,1,240)! SET RXB TO TEXT MODE
120 FOR D=0 TO 1E2 :: NEXT D
130 CALL POKER(1,232)!       SET RXB TO MULTI COLOR MODE
140 FOR D=0 TO 1E2 :: NEXT D
150 CALL POKER(0,2,1,2)!    SET RXB TO BIT MAP MODE
160 FOR D=0 TO 1E2 :: NEXT D
170 CALL POKER(0,224,0,32)! RXB NORMAL MODE

SAVE DSK1.POKER,IV254
NEW
100 ! POKEV IS A RXB COMMANDFOR PUTTING VALUES INTO VDP
120 CALL POKEV(512,65+96)!  PUT CHARACTER A AT ADDRESS  512 (32*16) ON SCREEN
130 ! A BIAS OF 96 MUST BE  ADDED TO CHARACTERS WHEN PUTON SCREEN

SAVE DSK1.POKEV,IV254
NEW
! RXB also has a catalog    routine CALL CAT(1) or
!  CALL CAT("DSK1.") or     CALL CAT(49) this would be  char 1 in ASCII
! RXB is smarter then most  other XB versions to catalogdrives
! RAMDISK can use           CALL CAT("DSKA.") or        CALL CAT(65) or CALL CAT
(A)
 
CALL KEY("",5,K,S)
NEW
CALL CAT(49)
! That was using            CALL CAT(49)                character 1 in ASCII

! Notice the LINESHOW 4     sectors long & MERGE format.

CALL KEY("",5,K,S)
NEW
! RXB CALL JOYST UPDATED

! NORMAL XB

CALL JOYST(1,A,B) :: CALL JOYST(2,C,D)

! RXB UPDATE less typing

CALL JOYST(1,A,B,2,C,D)

CALL KEY("",5,K,S)
NEW 
! JOYLOCATE and JOYMOTION
! JOYLOCATE is like you     combined 
! JOYST+LOCATE+IF key THEN  LINE NUMBER
! JOYMOTION is like you     combined
! JOYST+MOTION+IF key THEN  LINE NUMBER
! (way faster then normal   XB response times)

CALL KEY("",5,K,S)
NEW
! RXB CALL COLOR UPDATED

! NORMAL XB

FOR L=0 TO 14 :: CALL COLOR(L,2,11) :: NEXT L

! RXB COLOR UPDATE

CALL COLOR(ALL,2,11)

! RXB is much faster

CALL KEY("",5,K,S)
NEW
! RXB CALL GCHAR UPDATED
! NORMAL XB

CALL GCHAR(22,3,A) :: CALL GCHAR(22,4,B) :: CALL GCHAR(22,5,C)

! RXB GCHAR UPDATE

CALL GCHAR(22,3,A,22,4,B,22,5,C)

! As you can see saves bytesand much faster 
CALL KEY("",5,K,S)
NEW
! RXB has HGET like GCHAR   but unlike multiple GCHAR   only 1 character at a ti
me 
! RXB has a huge advantage  for saving program space    and making faster progra
ms

CALL HGET(23,1,14,X$)
CALL VGET(21,3,4,Y$)

! The two lines above would take many lines of GCHAR to do same thing and slower
 too
CALL KEY("",5,K,S)

PRINT X$:Y$

! HGET & VGET are way betterthen GCHAR to use obviously

CALL KEY("",5,K,S)
NEW
! RXB CALL HCHAR UPDATED    ALSO VCHAR UPDATED    

! NORMAL XB
CALL HCHAR(10,25,33,5) :: CALL HCHAR(11,25,33,6) :: CALL HCHAR(12,25,33,7)

! RXB UPDATE
CALL HCHAR(18,25,33,5,19,25,33,6,20,25,33,7)

! NOTICE RXB version must   have number of characters   to repeat or errors out 

CALL KEY("",5,K,S)
NEW
! RXB has HPUT like HCHAR & VCHAR but like mulitple ones in a row

CALL KEY("",5,K,S)
NEW
CALL HPUT(15,1,"HPUT TEST")
CALL VPUT(15,1,"VPUT TEST")

! Better then DISPLAY AT as uses entire screen and does vertical + horizontal

CALL KEY("",5,K,S)

NEW
! RXB CALL VERSION UPDATED

CALL VERSION(A) :: PRINT A

CALL KEY("",5,K,S)
NEW

! NEW RXB SOUND SUBROUTINES

CALL BEEP

! NEW RXB SUBROUTINE

CALL HONK

CALL KEY("",5,K,S)

NEW
! Create a XB program

100 REM Test
110 PRINT "THIS IS A TEST PROGRAM"
120 CALL BEEP
130 END

! SAVE THE PROGRAM

SAVE DSK1.TEST

CALL KEY("",5,K,S)
NEW
! HOW TO EDIT IN USER

OLD DSK1.TEST

RES 1000,100
NUM 1010,111
! REMARK HERE
! SHOW IT
! LET THEM KNOW IT
! DONE

LIST

RES 100,5

CALL KEY("",5,K,S)
LIST

SAVE DSK1.TEST2

CALL KEY("",5,K,S)
NEW
! RUN PROGRAMS BUT GO BACK   TO USER

CALL KEY("",5,K,S)
RUN "DSK1.TEST"
RUN "DSK1.TEST2"

CALL KEY("",5,K,S)
NEW
! MERGE PROGRAMS AND RUN

OLD DSK1.TEST2

RES 3333,4
SAVE DSK1.TEST3,MERGE

LIST

CALL KEY("",5,K,S)
NEW
OLD DSK1.TEST
MERGE DSK1.TEST3

LIST

CALL KEY("",5,K,S)

SAVE DSK1.MPGM,IV254
LIST

CALL KEY("",5,K,S)
NEW
! RXB IMPROVED SIZE
SIZE
CALL KEY("",5,K,S)
NEW
! NOW YOU SEE FREE SPACE ANDTHE FIRST FREE ADDRESS      LOCATION IN SIZE ALSO NO
W   ASSEMBLY SIZE AND LOCATIONS OF MEMORY

CALL KEY("",5,K,S)
10 CALL INIT :: CALL SIZE
20 CALL KEY("",5,K,S)
RUN
! SEE LOWER 8K CHANGED?

CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! Changing VDPSTACK triggersreset VDP & Program space sodoes a NEW after changes

! 10 CALL VDPSTACK(2392)
! >0958 STACK 
!NORMAL VDP STACK LOCATION

CALL KEY("",5,K,S)
10 CALL VDPSTACK(2392)

CALL KEY("",5,K,S)
RUN
SIZE
CALL KEY("",5,K,S)
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(4096)
! >1000 VDP STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(4096)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(6176)
! >1820 VDP STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(6176)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB VDPSTACK MANAGER

! CALL VDPSTACK(2392)
! >0958 STACK

!NORMAL STACK LOCATION

CALL KEY("",5,K,S)
CALL VDPSTACK(2392)
SIZE
CALL KEY("",5,K,S)
NEW
! RXB PROGRAM RAM MANAGER

! CALL PRAM(START-ADDRESS,  END-ADDRESS)
! Normal XB START >FFE7     (-25 DECIMAL)
! Normal XB END   >A040     (-24512 DECIMAL)
! 24K RAM minus 64 bytes

! CALL PRAM(-25,-24512)     (default previous value)
CALL KEY("",5,K,S)
CALL PRAM(-25,-24512)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! How about full 24K RAM
! START >FFFF               (24K+DEBUGGER)
! END >A000                 (24K+64 BYTES RAM)
! FULL 24K OF RAM FINALLY
! CALL PRAM(-1,-24576)

CALL KEY("",5,K,S)
CALL PRAM(-1,-24576)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >F000               (New high address)  
! END >B000                 (16K RAM)
! CALL PRAM(-4096,-20480)

CALL KEY("",5,K,S)
CALL PRAM(-4096,-20480)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFE7               (Normal XB address)
! END >E000                 (8K-8 BYTES RAM)
! CALL PRAM(-25,-8192)

CALL KEY("",5,K,S)
CALL PRAM(-25,-8192)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >D000               (New high address)
! END >C000                 (4K RAM)
! CALL PRAM(-12288,-16384)

CALL KEY("",5,K,S)
CALL PRAM(-12288,-16384)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFFF               (TI Debug area)
! END >FFE7                 (Normal XB High address)             
! (25 BYTES RAM)
! CALL PRAM(-1,-25)

CALL KEY("",5,K,S)
CALL PRAM(-1,-25)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! START >FFE7               (Normal XB High address)
! END >FFE6                 (1024 BYTES RAM)
! CALL PRAM(-25,-1048)

CALL KEY("",5,K,S)
CALL PRAM(-25,-1048)
SIZE 
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER
! OR this way too
! START >FFFF               (TI Debugger area)
! END >FF00                 (256 BYTES RAM)
! CALL PRAM(-1,-256)

CALL KEY("",5,K,S)
CALL PRAM(-1,-256)
SIZE
CALL KEY("",5,K,S)
NEW
! New RXB RAM MANAGER

! RESET RAM TO NORMAL START
! RESET RAM TO NORMAL END
! CALL PRAM(-25,-24512)

CALL KEY("",5,K,S)
CALL PRAM(-25,-24512)
SIZE
CALL KEY("",5,K,S)
NEW
10 ! If RXB has not blown   your mind watch this!

110 CALL FILES(0) 

120 ! You can do CALL FILES  from program mode now!

130 ! But notice 0 files?

140 ! RXB can do CALL FILES  with a modified 0 files!

150 ! RXB executes a NEW     after the CALL FILES so     you do not have to do t
hat  and in PROGRAM MODE or      EDIT MODE for you!

CALL KEY("",5,K,S)
SAVE "DSK1.CALLFILES",IV254
NEW
! RXB has CALL XB that will return to start title       screen or can be used li
ke  RUN programs. EXAMPLE:
! CALL XB("DSK1.XBFILE")
! Additonally CALL FILES is also built into CALL XB     EXMPLE:
! CALL XB("DSK1.PGM",file#) 
! RXB allows 0 to 15 Files 

CALL KEY("",5,K,S)
NEW
! TRACE FROM USER

OLD DSK1.TEST

TRACE

RUN

UNTRACE

CALL KEY("",5,K,S)
NEW
! USER IGNORES ERRORS

NUM
! ERRORS IN USER
GOTO 1000

RUN

! SAME AS BREAK OR FCTN4    (By the way FCTN4 does not  work in USER)

CALL KEY("",5,K,S)
NEW
100 ! NEW IN RXB IS LIKE IN XB BUT CAN BE CALLED IN A   PROGRAM
110 CALL NEW! PROGRAM IS    ERASED AND DEFAULTS TO THE  COMMAND MODE
120 ! RXB DOCUMENTS SHOW    CALL NEW IS FOR THE USER    RXB COMMAND RUN THAT DEM
O
    
CALL KEY("",5,K,S)
SAVE DSK1.NEW,IV254
RUN
100 ! NORMAL XB CLOSE
110 OPEN #1:"DSK1.FILE1"
120 OPEN #2:"DSK1.FILE2"
130 CLOSE #1
140 CLOSE #2

200 ! RXB CLOSE ALL
210 OPEN #1:"DSK1.FILE1"
220 OPEN #2:"DSK1.FILE2"
230 CALL CLSALL

CALL KEY("",5,K,S)
SAVE DSK1.CLSALL,IV254
NEW 
1 ! Use this to convert       plain text to RXB USER files
100 ON ERROR 170
110 OPEN #1:"DSK1.USERDEMO",INPUT
120 OPEN #2:"DSK1.BATCH",OUTPUT
130 LINPUT #1:Z$
140 IF LEN(Z$)=80 THEN X$=X$&Z$ :: GOTO 130
150 IF LEN(Z$)<80 THEN PRINT #2:X$&Z$&CHR$(13)
160 X$,Z$="" :: GOTO 130
170 CALL CLSALL
180 END

SAVE DSK1.DV80TOUSER,IV254
NEW
! RXB Binary SAVE routine   called BSAVE and BLOAD have been changed to PSAVE an
d   PLOAD 
! The previous version 2015 were 8K sized files but 2020versions are 4K in size 
    files
! This change was for SAMS  support as any 4K page can  be loaded or saved      
    anywhere in RAM now
! To explain 2,3,A,B,C,D,E,Fis the HEX location of RAM  boundries thus RXB can l
oad 4K files into RAM for SAMS 

CALL KEY("",5,K,S)
NEW
100 CALL CLEAR
110 CALL MAGNIFY(2)
120 CALL SCREEN(15)
130 CALL COLOR(1,1,15)
140 FOR S=2 TO 8
150 CALL COLOR(S,2,15)
160 NEXT S
170 CALL SPRITE(#1,87,13,84,26)
180 CALL SPRITE(#2,73,13,58,58)
190 CALL SPRITE(#3,78,13,32,90)
200 CALL SPRITE(#4,68,13,58,122)
210 CALL SPRITE(#5,89,13,32,154)
220 CALL SPRITE(#6,88,13,58,186)
230 CALL SPRITE(#7,66,13,84,218)
240 CALL SPRITE(#8,51,12,128,90)
250 CALL SPRITE(#9,46,12,128,122)
260 CALL SPRITE(#10,48,12,128,154)
270 CALL SPRITE(#11,42,5,1,1,0,127)
280 CALL SPRITE(#12,42,5,1,243,127,0)
290 CALL SPRITE(#13,42,5,176,243,0,-127)
300 CALL SPRITE(#14,42,5,176,1,-127,0)
310 CALL SPRITE(#15,42,16,1,128,0,111)
320 CALL SPRITE(#16,42,16,96,243,111,0)
330 CALL SPRITE(#17,42,16,176,128,0,-111)
340 CALL SPRITE(#18,42,16,96,1,-111,0)
350 CALL SPRITE(#19,42,7,1,1,0,99)
360 CALL SPRITE(#20,42,7,1,243,99,0)
370 CALL SPRITE(#21,42,7,176,243,0,-99)
380 CALL SPRITE(#22,42,7,176,1,-99,0)
390 FOR R=3 TO 21
400 CALL HPUT(R,3,RPT$("a",28))
410 NEXT R
420 CALL CHAR(97,"00FF00FF00FF00FF")
430 ! THIS IS HOW THE TITLE SCREEN WAS CREATED AND WAS  SAVED
440 CALL HCHAR(3,3,96,28)
450 CALL VCHAR(3,3,96,20)
460 CALL HCHAR(22,3,96,28)
470 CALL VCHAR(3,30,96,20)
480 CALL HPUT(15,5,"RICHARD LYNN GILBERTSON")
490 CALL HPUT(20,9,"<<<PUSH A KEY>>>")
500 ! LOOP HERE FOR MOVEMENT
510 CALL CHAR(96,"FF818181818181FF")
520 IF RND>.5 THEN CALL COLOR(9,RND*15+1,15)
530 CALL CHAR(96,"00E7E7E7E7E7E700")
540 CALL KEY(0,K,S):: IF S=0 THEN 510
550 ! GET SPRITE MOTION IN N
560 CALL PEEK(-31878,N)
570 ! MOVE VDP TO LOW 8K RAM
580 CALL MOVES("VR",2079,0,8192)
590 ! SAVE RAM TO DISK
600 CALL PSAVE(2,"DSK1.SCREEN")

! SET UP SCREEN AND PSAVE IT

CALL KEY("",5,K,S)
SAVE DSK1.PSAVESCRN,IV254
RUN
100 ! RELOAD SAVED MEMORY
110 CALL PLOAD(2,"DSK1.SCREEN")
120 ! RESET MAGNIFICATION
130 CALL MAGNIFY(2) :: CALL SCREEN(15)
140 ! MOVE FROM RAM TO VDP
150 CALL MOVES("RV",2079,8192,0)
160 ! RESET SPRITE MOTION
170 CALL LOAD(-31878,22)
180 ! LOOP HERE FOR MOVEMENT.
190 CALL CHAR(96,"FF818181818181FF") :: IF RND>.5 THEN CALL COLOR(9,RND*16,15)
200 CALL CHAR(96,"00E7E7E7E7E7E700")
210 CALL KEY(5,K,S):: IF S=0 THEN 190

CALL KEY("",5,K,S)
SAVE DSK1.PLOADSCRN,IV254
RUN
NEW
! RXB has built in support  for SAMS memory card or     sidecar up to 64 Meg SAM
S

! PSAVE and PLOAD are used  to SAVE and LOAD SAMS pages 4K at a time

! Access to SAMS is using   CALL SAMS(boundry,page#) 

! boundry = 2,3,A,B,C,D,E,F page# = 0 to 65536 4K pages

! Of course this requires   a SAMS memory card 

CALL KEY("",5,K,S)
NEW
! RXB has built in support  subprograms so this will    show them to you

! This RXB program uses     CALL PEEKG that is a        peek GROM routine

! This RXB program also     finds the address of that   subprogram in GROM

! Lastly it shows the link  to next subprogram and      the actual address in GR
OM

CALL KEY("",5,K,S)
NEW 
10 ! RXB EXAMPLE             RXB SUBPROGRAM FINDER
100 CALL CLEAR :: ADDRESS=-24538
110 RESTORE :: FOR I=1 TO 2 :: READ X$,Y$,Z$ :: PRINT X$;TAB(11);Y$;TAB(22);Z$ :
: NEXT I
120 CALL PEEKG(ADDRESS,B1,B2) :: CALL HEX(B1,B1$,B2,B2$) :: ADDRESS$=SEG$(B1$,3,
2)&SEG$(B2$,3,2)
130 CALL PEEKG(ADDRESS+2,LENGTH)
140 CALL MOVES("G$",LENGTH,ADDRESS+3,N$)
150 CALL PEEKG(ADDRESS+3+LENGTH,S1,S2) :: CALL HEX(S1,S1$,S2,S2$) :: S$=SEG$(S1$
,3,2)&SEG$(S2$,3,2)
160 CALL HEX(ADDRESS,A$) :: PRINT A$;"-";ADDRESS$;" ";TAB(11);N$;" ";TAB(22);S$ 
:: PRINT
170 DATA HEADER,SUBPROGRAM,START,*******,**********,*******
180 CALL HEX(ADDRESS$,ADDRESS) :: IF ADDRESS THEN 120

SAVE DSK1.SUBPGMFNDR,IV254
RUN
CALL KEY("",5,K,S)
NEW
! Lets create a USER file   while in USER running a     USER DV80 file?
! Yea that is right we are  going to create a DV80 file from DV80 and run it!
CALL KEY("",5,K,S)

! CREATE A USER FILE FROM   USER FILE

OPEN #1:"DSK1.TEST-USER",OUTPUT
PRINT #1:"1 CALL CLEAR ! TEST OF USER"&CHR$(13)
PRINT #1:"2 A$="&CHR$(34)&" RXB USER "&CHR$(34)&CHR$(13)
PRINT #1:"3 B$="&CHR$(34)&"   DEMO   "&CHR$(34)&CHR$(13)
PRINT #1:"4 C$="&CHR$(34)&" FINISHED "&CHR$(34)&CHR$(13)
PRINT #1:"5 CALL HPUT(12,11,A$,14,11,B$,16,11,C$)"&CHR$(13)
PRINT #1:"6 PRINT "&CHR$(34)&"ALL DONE!"&CHR$(34)&CHR$(13)
PRINT #1:"7 FOR Z=1 TO 5000 :: NEXT Z"&CHR$(13)
PRINT #1:"8 CALL CAT(1)"&CHR$(13)
print #1:"RUN"
CLOSE #1

CALL KEY("",5,K,S)
NEW
! USER in this demo just    created files on DSK1

! USER CAN CALL USER FILES  IF IT IS THE LAST COMMAND

! OK NOW WE ARE GOING TO    MAKE A TON OF RXB PROGRAMS
! THIS IS GOING TO TAKE     SOMETIME TO MAKE THEM...

CALL KEY("",5,K,S)
NEW
100 ! Normal XB CALL KEY      routine vs RXBONKEY
110 CALL CLEAR
120 PRINT "XB CHOOSE A KEY:":"Yes, No, Maybe, End"
130 CALL KEY(3,K,S)
140 IF K=89 THEN PRINT "YES" :: GOTO 130
150 IF K=78 THEN PRINT "NO" :: GOTO 130
160 IF K=77 THEN PRINT "MAYBE" :: GOTO 130
170 IF K=69 THEN PRINT "END" :: GOTO 190
180 GOTO 130
190 ! RXB  CALL ONKEY routine
200 ! RXB CALL ONKEY
210 CALL CLEAR
220 PRINT "RXB CHOOSE A KEY:":"Yes, No, Maybe, End"
230 CALL ONKEY("YNME",3,K,S)GOTO 250,260,280,280
240 GOTO 230
250 PRINT "Yes!" :: GOTO 230
260 PRINT "Nn!" :: GOTO 230
270 PRINT "Maybe" :: GOTO 230
280 PRINT "End!"

SAVE DSK1.RXBONKEY,IV254
NEW
100 ! CATALOG ALL DISKS
110 N=49
120 ON ERROR 150
130 N=N+1
140 CALL CAT(N)
150 PRINT D$
160 IF N<128 THEN 120 ELSE END

SAVE DSK1.CATALL,IV254
NEW
100 ! JOYLOCATE              JOYST + LOCATE + IF KEY GOTOLINE NUMBER
110 ! As this does all this in asingle command should  be   used in place of nor
mal XB  more compliated version
120 CALL CLEAR
130 CALL CHAR(143,"FFFFFFFFFFFFFFFF")
140 CALL SPRITE(#1,143,2,9,190)
150 CALL JOYLOCATE(1,X,Y,8,8,#1,R,C,K)GOTO 180
160 PRINT X;Y;K;R;C
170 GOTO 150
180 PRINT X;Y;K;R;C;"FIRE"
190 GOTO 150

SAVE DSK1.JLOCATE,IV254
NEW
100 ! RXB CALL JMOTION
110 ! JOYMOTION              JOYST + MOTION + IF KEY GOTOLINE NUMBER
120 ! As this does all this in asingle command should  be   used in place of nor
mal XB  more compliated version
130 CALL CLEAR
140 CALL CHAR(143,"FFFFFFFFFFFFFFFF")
150 CALL SPRITE(#1,143,2,9,190,20,0)
160 CALL JOYMOTION(1,X,Y,#1,9,9,K)GOTO 190
170 PRINT X;Y,K
180 GOTO 160
190 PRINT X;Y,K;"FIRE"
200 GOTO 160

SAVE DSK1.JMOTION,IV254
NEW
100 ! RUN FOR ONE HOUR AND    COMPARE PRINT X XB VS RXB
110 ! NORMAL XB DISTANCE
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL DISTANCE(#1,#2,D)
150 CALL DISTANCE(#1,#3,E)
160 CALL DISTANCE(#2,#3,F)
170 X=X+1 :: PRINT D;E;F
180 GOTO 140! X IS COUNTER
190 !
200 ! RXB DISTANCE
210 CALL CLEAR :: X=190
220 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
230 CALL DISTANCE(#1,#2,D,#1,#3,E,#2,#3,F)
240 X=X+1 :: PRINT D;E;F
250 GOTO 230! X IS COUNTER
260 ! RUN FOR 1 HOUR TEST OF    NORMAL DISTANCE XB VS RXB

SAVE DSK1.DISTANCE,IV254
NEW
10 ! RXB EXAMPLE            CALL CHAR(ALL,string)
20 FOR L=0 TO 256 :: PRINT CHR$(L);:: NEXT L
30 S$="0123456789ABCDEF"
40 CALL CHAR(ALL,SEG$(S$,INT(RND*15)+1,INT(RND*15)+1))
50 Z=Z+1 :: IF Z=50 THEN END ELSE 40

SAVE DSK1.CHARALL,IV254
NEW
100 ! NORMAL XB CHARSET
110 CALL HCHAR(1,1,32,768) :: PRINT "NORMAL XB CALL CHARSET": :
120 FOR L=159 TO 30 STEP-1 :: PRINT CHR$(L);" "; :: CALL CHAR(L,"4567") :: NEXT 
L
130 FOR D=1 TO 600 :: NEXT D
140 CALL CHARSET
150 PRINT "XB CHARSET RESETS 32 TO 95": : :
160 FOR D=1 TO 900 :: NEXT D
170 ! RXB CHARSETALL
180 CALL CHARSETALL
190 PRINT "RXB CHARSETALL 30 TO 159": :
200 PRINT "PRESS ANY KEY"
210 CALL KEY("",5,K,S)

SAVE DSK1.CHARSETALL,IV254
NEW
10 ! RXB EXAMPLE            CALL SWAPCHAR(char,char)    CALL SWAPCHAR(value#,val
ue#)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*20),INT(A(
RND*1))*INT(RND*20))
140 NEXT S
150 CALL SWAPCOLOR(#INT(RND*28)+1,#INT(RND*28)+1):: CALL SWAPCHAR(INT(RND*28)+64
,INT(RND*28)+64)
160 Z=Z+1 :: IF Z=50 THEN END ELSE 150

SAVE DSK1.SWAP,IV254
NEW
10 ! RXB EXAMPLE            CALL MAGNIFY(factor[,...])
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT
(RND*127))
140 NEXT S
150 CALL MAGNIFY(1,2,1) :: GOTO 150 
160 ! MAGNIFY changed

SAVE DSK1.MAGNIFY,IV254
NEW
100 CALL CLEAR
110 T$="HELLO WORLD"
120 B$=" "
130 CALL BIAS(1,T$,1,B$)
140 FOR X=757 TO 0 STEP-1
150 CALL MOVES("$V",11,T$,X,"$V",1,B$,X+10)
170 NEXT X

SAVE DSK1.MOVESHELLO,IV254
NEW
100 ! RXB EXAMPLE            CALL MOVES(GROM to screen)
110 FOR GA=0 TO 32767 STEP 768 :: CALL MOVES("GV",768,GA,0):: NEXT GA
120 ! RXB EXAMPLE            CALL MOVES (RIPPLE EXAMPLE)
130 CALL HCHAR(1,1,32)
140 CALL MOVES("VV",767,0,1)
150 ! RXB EXAMPLE            CALL MOVES (SCAN VDP)
160 FOR V=0 TO 16384 STEP 768 :: CALL MOVES("VV",768,V,0):: NEXT V
170 ! RXB EXAMPLE            CALL MOVES(RAM to screen)
180 FOR R=0 TO 8192 STEP 768 :: CALL MOVES("RV",768,R,0) :: NEXT R

SAVE DSK1.MOVES,IV254
NEW
10 ! RXB EXAMPLE       CALL MOVES(type$,bytes,from,to)
20  PRINT "Disk controller EPROM chip"
100 CALL CHAR(31,"F0F0F0F0F0F0F0F0")
110 CALL IO(3,8,2176,255) ! TURN ON EPROM
120 FOR A=16384 TO 24576 STEP 224
130 CALL MOVES("R$",224,A,T$)
140 CALL HEX(A,H$)
150 PRINT " ADDRESSS=";A;"HEX=";H$: :T$: :
160 FOR L=1 TO 400 :: NEXT L
170 NEXT A
180 CALL CHAR(31,"00")
190 CALL IO(3,8,2176,0) ! TURN OFF EPROM

SAVE DSK1.MOVESDSR,IV254
NEW
10 ! RXB EXAMPLE CALL BIAS
20 ! MOVES get VDP from     screen into a String         Variable X$
30 CALL MOVES("V$",255,511,X$)
40 ! CALL BIAS removes 96   screen bias from all         characters in String   
         Variable X$
50 CALL BIAS(0,X$)
60 ! After screen bias is   removed it can be printed    on screen
70 PRINT X$

SAVE DSK1.BIAS,IV254
NEW
10 ! RXB EXAMPLE             RXB SUBPROGRAM FINDER
100 CALL CLEAR :: ADDRESS=-24538
110 RESTORE :: FOR I=1 TO 2 :: READ X$,Y$,Z$ :: PRINT X$;TAB(11);Y$;TAB(22);Z$ :
: NEXT I
120 CALL PEEKG(ADDRESS,B1,B2) :: CALL HEX(B1,B1$,B2,B2$) :: ADDRESS$=SEG$(B1$,3,
2)&SEG$(B2$,3,2)
130 CALL PEEKG(ADDRESS+2,LENGTH)
140 CALL MOVES("G$",LENGTH,ADDRESS+3,N$)
150 CALL PEEKG(ADDRESS+3+LENGTH,S1,S2) :: CALL HEX(S1,S1$,S2,S2$) :: S$=SEG$(S1$
,3,2)&SEG$(S2$,3,2)
160 CALL HEX(ADDRESS,A$) :: PRINT A$;"-";ADDRESS$;" ";TAB(11);N$;" ";TAB(22);S$ 
:: PRINT
170 DATA HEADER,SUBPROGRAM,START,*******,**********,*******
180 CALL HEX(ADDRESS$,ADDRESS) :: IF ADDRESS THEN 120

SAVE DSK1.SUBPGMFNDR,IV254
NEW
10 ! RXB EXAMPLE            CALL POKER(register,value)
100 CALL CLEAR :: FOR I=0 TO 764 STEP 8 :: CALL POKEV(I,161,162,163,164,165,166,
167,168) :: NEXT I
110 CALL CLEAR :: FOR I=0 TO 758 STEP 16 :: CALL POKEV(I,161,162,163,164,165,166
,167,168,169,170,172,173,174,175,176) :: NEXT I
120 CALL CLEAR :: FOR I=126 TO 223 :: CALL POKEV(I,I+1,I+2,I+3,I+4,I+5,I+6,I+7) 
:: NEXT I
130 PRINT: :"SCREEN COLOR CHANGES" :: FOR T=1 TO 5 :: FOR I=0 TO 15 :: CALL POKE
R(7,1) :: NEXT I :: NEXT T :: CALL SCREEN(8)
140 A$="!@#$%^&*()+1234567890=-:><,.;/~_?'|{}\`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefg
hijklmnopqrstuvwxyz" :: FOR I=1 TO 5 :: PRINT A$ :: NEXT I
150 PRINT: :"CHARACTER COLOR CHANGES" :: FOR I=30 TO 70 :: FOR T=2063 TO 2076 ::
 CALL POKEV(T,I) :: NEXT T :: NEXT I :: CALL CHARSET :: PRINT
160 PRINT "PRESS A KEY FOR TEXT MODE": : :: CALL BEEP
170 CALL KEY("",0,K,S) :: CALL POKER(7,244) :: CALL POKER(1,240)
180 PRINT "       PRESS A KEY FOR MULTI COLOR MODE": : :: CALL BEEP
190 CALL KEY("",0,K,S) :: CALL POKER(1,232) :: GOSUB 230 :: CALL POKER(1,224)
200 PRINT "PRESS A KEY FOR BIT MAP MODE": : :: CALL BEEP
210 CALL KEY("",0,K,S) :: CALL POKER(0,2) :: CALL POKER(1,224)
220 GOSUB 230 :: CALL POKER(0,0) :: END
230 FOR I=1 TO 800 :: NEXT I :: RETURN

SAVE DSK1.POKER,IV254
NEW
100 ! RXB EXAMPLE            CALL MOTION(STOP,GO)
110 CALL CLEAR :: CALL CHAR(128,RPT$("F",16)) :: CALL MAGNIFY(2)
120 A$="OUT" :: GOSUB 130 :: A$="" :: GOSUB 130 :: CALL QUITON :: END
130 CALL HPUT(1,3,"MOTION WITH"&A$&" RXB") :: IF A$="" THEN CALL MOTION(STOP)
140 FOR A=1 TO 11 :: CALL SPRITE(#A,128,2,A*16-7,1,0,30) :: NEXT A :: IF A$="" T
HEN CALL MOTION(GO)
150 CALL HPUT(24,4,"PRESS ANY KEY TO CONTINUE.") :: CALL KEY("",0,K,S) :: CALL D
ELSPRITE(ALL) :: CALL CLEAR :: RETURN

SAVE DSK1.MOTIONGO,IV254
NEW
10 ! RXB EXAMPLE            CALL MOTION(GO,STOP)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A(RND*1))*INT
(RND*127))
140 NEXT S
150 N=N+1 :: ON INT(RND*3)+1 GOSUB 160,170,180 :: IF N>50 THEN END ELSE 150
160 CALL MOTION(GO) :: RETURN
170 CALL MOTION(STOP) :: RETURN
180 FOR DELAY=0 TO 200 :: NEXT DELAY :: RETURN

SAVE DSK1.MOTIONSTOP,IV254
NEW
10 ! RXB EXAMPLE            CALL COLOR(ALL,fore,back)
20 FOR L=0 TO 256 :: PRINT CHR$(L);:: NEXT L
30 CALL COLOR(ALL,RND*15+1,RND*15+1)
40 Z=Z+1 :: IF Z=50 THEN END ELSE 30

SAVE DSK1.COLORALL,IV254
NEW
100 ! COLOR IN RXB HAS ALL  ADDED TO CHANGE ALL SETS    FROM 0 TO 16
120 FOR X=0 TO 255 :: PRINT CHR$(X);
130 NEXT X
140 CALL COLOR(ALL,1,2)! ALLSETS ALL TO TRANPARENT BLACK
150 FOR X=0 TO 2E2 :: NEXT X
160 CALL COLOR(ALL,1,2,ALL,2,1) :: GOTO 160! CREATES A  OPTICAL EFFECT
200 GOTO 200

SAVE DSK1.ALLCOLOR,IV254
NEW
10 ! RXB EXAMPLE            CALL MOTION(ALL,x,y)
100 A(0)=-127 :: A(1)=127 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,2,20+S,50+S,A(RND)*RND,A(RND)*RND)
140 NEXT S
150 CALL MOTION(ALL,A(RND)*RND,A(RND)*RND)
160 C=C+1 :: IF C<70 THEN 150
170 ! pretty cool huh?

SAVE DSK1.MOTIONALL,IV254
NEW
! RXB EXAMPLE               CALL HEX(number,string)
10 ! Decimal & Hexidecimal
11 FOR D=-32000 TO 30000 STEP 1000
12 CALL HEX(D,H$)
13 PRINT "DEC=";D,"HEX=";H$
100 ! Hexidecimal to Decimal
120 CALL HEX(H$,D)
130 PRINT "HEX=";H$,"DEC=";D
140 NEXT D

SAVE DSK1.HEX~DEC,IV254
NEW
100 ! NUMBERS VS STRINGS
110 DATA 200,124,97,249,140,77,81,173,254,78,93,12,38,65,55,6,0
120 READ N :: B$="BYTES"
130 CALL HEX(N,N$)
140 S$=S$&SEG$(N$,2,2)
150 IF N<>0 THEN 120
160 PRINT "DATA: ";8*16,B$
170 PRINT "STRING:";LEN(S$)+1,B$
180 PRINT "SAVED: ";(8*16)-(LEN(S$)+1),B$
190 ! 8 BYTES PER DATA       WHILE STRING IS 2 BYTES

SAVE DSK1.HEXSTRING,IV254
NEW
10 ! RXB EXAMPLE            CALL SWAPCHAR(char,char)    CALL SWAPCHAR(value#,val
ue#)
100 A(0)=-1 :: A(1)=1 :: CALL MOTION(GO)
110 CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15)
120 FOR S=1 TO 28
130 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*20),INT(A(
RND*1))*INT(RND*20))
140 NEXT S
150 CALL SWAPCOLOR(#INT(RND*28)+1,#INT(RND*28)+1):: CALL SWAPCHAR(INT(RND*28)+64
,INT(RND*28)+64)
160 Z=Z+1 :: IF Z=50 THEN END ELSE 150

SAVE DSK1.SWAP,IV254
NEW
10 ! RXB EXAMPLE            CALL INVERSE(ALL)
100 CALL INVERSE(ALL)
110 A=A+1 :: IF A<8 THEN 100
120 ! Inverts all character definitions

SAVE DSK1.INVERSEALL,IV254 
NEW
100 ! INVERSE IS A RXB      COMMAND THAT INVERTS THE ALLTHE BITS IN A CHARACTER 
CODE
110 ! INVERSE HAS ANOTHER   USE FOR PROGRAMMERS
120 PRINT "CHARACTER # (32 TO 159)": :
130 ACCEPT AT(24,1)VALIDATE(DIGIT)SIZE(3)BEEP:X :: PRINT CHR$(X):
140 CALL CHARPAT(X,X$) :: PRINT X$;" NORMAL"
150 CALL INVERSE(X)
160 CALL CHARPAT(X,X$) :: PRINT X$;" INVERSED": :
170 GOTO 120

SAVE DSK1.INVERSED,IV254
NEW
1 ! RXB has improved a COINC  routine run this demo to seethe results!
100 ! RUN FOR 1 HOUR AND     AND PRINT X FOR XB VS RXB
110 ! NORMAL XB COINC
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL COINC(ALL,A)
150 CALL COINC(#1,#2,12,B)
160 CALL COINC(#1,#3,12,C)
170 CALL COINC(#2,#3,12,D)
180 X=X+1 :: PRINT A;B;C;D
190 GOTO 140
200 !
210 ! RXB COINC
220 CALL CLEAR :: X=190
230 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
240 CALL COINC(ALL,A,#1,#2,12,B,#1,#3,12,C,#2,#3,12,D)
250 X=X+1 :: PRINT A;B;C;D
260 GOTO 240

SAVE DSK1.COINC,IV254
NEW
10 ! RXB EXAMPLE
100 ! This program gives the illusion of sprites that    bank 90% at a time
110 CALL MAGNIFY(2) :: CALL CLEAR :: CALL SCREEN(15) :: CALL MOTION(GO)
120 CALL SPRITE(#1,65,2,100,10,0,35,#2,66,16,10,140,25,0)
130 CALL COINC(ALL,V)
140 IF V THEN CALL SWAPCHAR(65,66) :: CALL RMOTION(#1) :: CALL SWAPCOLOR(#1,#2) 
:: GOSUB 160
150 GOTO 130 :: FOR L=1 TO 600 :: NEXT L
160 A=A+1 :: IF A<5 THEN RETURN

SAVE DSK1.SPRITESWAP,IV254
NEW
10 ! RXB EXAMPLE             CALL GMOTION(#sprite,x,y)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2):: CALL SCREEN(15) :: CALL
 MOTION(GO)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A
(RND*1))*INT(RND*127))
130 NEXT S
140 S=INT(RND*28)+1 :: CALL GMOTION(#S,X,Y):: CALL HPUT(24,3,"CALL GMOTION(#"&ST
R$(S)&","&STR$(X)&","&STR$(Y)&")      ") :: FOR L=1 TO 1000 :: NEXT L
150 CALL MOTION(#S,Y,X):: Z=Z+1 :: IF Z<8 THEN 140

SAVE DSK1.GMOTION,IV254
NEW
10 ! RXB EXAMPLE            CALL GMOTION(#sprite,x,y)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15) :: CAL
L MOTION(GO)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*127),INT(A
(RND*1))*INT(RND*127))
130 NEXT S
140 S=INT(RND*28)+1 :: CALL GMOTION(#S,X,Y) :: CALL HPUT(24,3,"CALL GMOTION(#"&S
TR$(S)&","&STR$(X)&","&STR$(Y)&")      ") :: FOR L=1 TO 1000 :: NEXT L
150 CALL MOTION(#S,Y,X) :: Z=Z+1 :: IF Z<8 THEN 140
160 ! GMOTION gets motion   from one sprite and puts     into another sprite

SAVE DSK1.G~MOTION,IV254
NEW
10 ! RXB EXAMPLE            CALL RMOTION(#sprite)       CALL RMOTION(ALL)
100 A(0)=-1 :: A(1)=1 :: CALL CLEAR :: CALL MAGNIFY(2) :: CALL SCREEN(15)
110 FOR S=1 TO 28
120 CALL SPRITE(#S,64+S,INT(RND*16)+1,20+S,50+S,INT(A(RND*1))*INT(RND*32),INT(A(
RND*1))*INT(RND*32))
130 NEXT S
140 IF RND>.2 THEN CALL RMOTION(#INT(RND*28)+1)ELSE CALL RMOTION(ALL)
150 Z=Z+1 :: IF Z<200 THEN 140
160 ! As this does all this  in a single command should  be used in place of nor
mal  XB  more compliated version

SAVE DSK1.RMOTION,IV254
NEW
10 ! RXB EXAMPLE CALL IO      (SOUND LIST)
100 A=8191
110 DATA 5,159,191,223,255,227,1
120 DATA 9,142,1,164,2,197,1,144,182,211,6
130 DATA 3,145,183,212,5
140 DATA 3,146,184,213,4
150 DATA 5,167,4,147,176,214,5
160 DATA 3,148,177,215,6
170 DATA 3,149,178,216,7
180 DATA 5,202,2,150,179,208,6
190 DATA 3,151,180,209,5
200 DATA 3,152,181,210,4
210 DATA 5,133,3,144,182,211,5
220 DATA 3,145,183,212,6
230 DATA 3,146,184,213,7
240 DATA 5,164,2,147,176,214,6
250 DATA 3,148,177,215,5
260 DATA 3,149,178,216,4
270 DATA 5,197,1,150,179,208,5
280 DATA 3,151,180,209,6
290 DATA 3,152,181,210,7
300 DATA 3,159,191,223,0
310 A=A+1 :: READ B :: CALL POKEV(A,B)
320 IF B=0 THEN 330 ELSE 310
330 CALL IO(1,8192)

SAVE DSK1.IO~CHIMES,IV254
NEW
100 CALL CLEAR! CRASH
110 DATA 2,228,242,5
120 DATA 2,228,240,18
130 DATA 2,228,241,16
140 DATA 2,228,242,14
150 DATA 2,228,243,12
160 DATA 2,228,244,10
170 DATA 2,229,245,9
180 DATA 2,229,246,8
190 DATA 2,229,247,7
200 DATA 2,229,248,6
210 DATA 2,229,249,5
220 DATA 2,230,250,4
230 DATA 2,230,251,3
240 DATA 2,230,252,2
250 DATA 2,230,253,1
260 DATA 2,230,254,1
270 DATA 1,255,0,0
280 FOR AD=4096 TO 4160 STEP 4
290 READ V1,V2,V3,V4
300 CALL POKEV(AD,V1,V2,V3,V4)
310 NEXT AD
320 CALL IO(1,4096)
330 PRINT "CRASH": :"TYPE:":"CALL IO(1,4096)"

SAVE DSK1.IO~CRASH,IV254
NEW
100 ! RUN FOR 1 HOUR AND     AND PRINT X FOR XB VS RXB
110 ! NORMAL XB COINC
120 CALL CLEAR :: X=190
130 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
140 CALL COINC(ALL,A)
150 CALL COINC(#1,#2,12,B)
160 CALL COINC(#1,#3,12,C)
170 CALL COINC(#2,#3,12,D)
180 X=X+1 :: PRINT A;B;C;D
190 GOTO 140
200 !
210 ! RXB COINC
220 CALL CLEAR :: X=190
230 CALL SPRITE(#1,65,2,9,X,20,0,#2,66,2,9,X,30,0,#3,67,2,9,X,-20,0)
240 CALL COINC(ALL,A,#1,#2,12,B,#1,#3,12,C,#2,#3,12,D)
250 X=X+1 :: PRINT A;B;C;D
260 GOTO 240
270 ! 1 HOUR TEST XB VS RXB

SAVE DSK1.COINC,IV254
NEW
1 ! XBRAMDISK used for saving 8K or less XB programs.
100 !Saved program will stay  in memory as long as you do not CALL INIT or turn 
memory expansion off.
110 !It will even stay in     memory when switching       cartrides with a WIDGE
T.
200 CALL CLEAR
220 CALL CHAR(42,"AA55AA55AA55AA55",91,"7E8199A1A199817E")
230 CALL CHAR(45,RPT$("0",8)&"FF"&RPT$("0",10)&"10387CFEFE")
240 CALL CLEAR :: CALL HCHAR(2,4,42,26)
250 CALL VCHAR(3,4,42,5) :: CALL VCHAR(3,29,42,5)
260 DISPLAY AT(5,9)SIZE(12):"RAM-DISKETTE"
270 CALL HCHAR(8,4,42,26)
280 DISPLAY AT(12,4):"[ MARTIN KOTULLA 1985"
290 CALL HCHAR(13,6,45,22) :: DISPLAY AT(17,7):"DATAs CHECK?   Y"
296 DISPLAY AT(22,4):"CALL LINK("&CHR$(34)&" LOAD"&CHR$(34)&") retrieve"
300 ACCEPT AT(17,22)BEEPSIZE(-1)VALIDATE("YN"):JN$
310 IF JN$="N" THEN 360
320 FOR I=8192 TO 8458 STEP 2 :: READ A,B :: SUM=SUM+A+B :: NEXT I
330 DISPLAY AT(20,5):"THE DATA-LINES ARE"
340 IF SUM<>20638 THEN DISPLAY AT(22,10):"INCORRECT!" :: END
350 DISPLAY AT(22,11):"CORRECT!"
360 CALL INIT :: RESTORE
370 FOR I=8192 TO 8458 STEP 2 :: READ A,B :: CALL LOAD(I,A,B) :: NEXT I
380 CALL CLEAR :: STOP
390 DATA 032,068,255,255,000,000,170,085,000,000,041,097,032,056,033,126
400 DATA 032,056,033,226,032,056,035,076,032,056,036,050,032,056,036,110
410 DATA 032,056,036,132,032,056,036,144,247,147,248,118,255,231,247,146
420 DATA 255,255,076,079,065,068,032,032,032,196,083,065,086,069,032,032
430 DATA 032,122,000,000,002,001,032,050,002,129,032,066,027,014,192,001
440 DATA 002,002,131,074,140,176,022,006,140,176,022,004,140,176,022,002
450 DATA 192,048,004,080,002,033,000,008,016,239,002,000,037,000,200,000
460 DATA 131,034,002,224,131,224,004,096,000,206,002,224,032,008,192,032
470 DATA 131,132,096,032,131,048,002,032,033,012,002,128,064,000,026,003
480 DATA 002,000,011,000,016,236,007,032,032,048,192,032,131,048,002,001
490 DATA 033,012,220,112,136,000,131,132,018,252,200,032,131,048,032,040
500 DATA 200,032,131,050,032,042,200,032,131,132,032,044,200,032,131,134
510 DATA 032,046,016,029,002,224,032,008,200,032,032,048,032,048,022,003
520 DATA 002,000,029,000,016,204,192,032,032,040,002,001,033,012,220,049
530 DATA 136,000,032,044,018,252,200,032,032,040,131,048,200,032,032,042
540 DATA 131,050,200,032,032,044,131,132,200,032,032,046,131,134,004,192
550 DATA 216,000,131,124,002,224,131,224,004,096,000,112
560 END

SAVE DSK1.XBRAMDSK,IV254
NEW
100 ! COLLIDE SPRITES
110 CALL CLEAR! SPRITES
120 CALL SPRITE(#1,65,2,9,99,20,22,#2,66,2,64,99,30,25,#3,67,2,9,99,-20,-25)
130 CALL COLLIDE(#1,#2,8,R1,C1,#1,#3,8,R2,C2,#2,#3,8,R3,C3)
140 IF R1+C1+R2+C2+R3+C3 THEN 150 ELSE 130
150 PRINT "#1";R1;C1;"#2";R2;C2;"#3";R3;C3
160 R1,C1,R2,C2,R3,C3=0
170 GOTO 130

SAVE DSK1.COLLIDE#,IV254
NEW
100 ! COLLIDE LOCATION
110 CALL CLEAR! SPRITES
120 CALL SPRITE(#1,65,2,9,99,20,22,#2,66,2,64,99,30,25,#3,67,2,9,99,-20,-25)
130 CALL COLLIDE(#1,99,99,8,R1,C1,#2,99,99,8,R2,C2,#3,99,99,8,R3,C3)
140 IF R1+C1+R2+C2+R3+C3 THEN 150 ELSE 130
150 PRINT "#1";R1;C1;"#2";R2;C2;"#3";R3;C3
160 R1,C1,R2,C2,R3,C3=0
170 GOTO 130

SAVE DSK1.COLLIDELOC,IV254
NEW
100 CALL VCHAR(24,32,32,768)
110 CALL HCHAR(24,32,65,-384,1,1,66,384)
120 CALL VCHAR(24,32,66,-384,1,1,65,384)
130 CALL HCHAR(24,32,67,-384,1,1,68,384)
140 CALL HCHAR(24,32,32,-768)
150 END

SAVE DSK1.HCHARVCHAR,IV254
NEW
CALL USER("DSK1.TEST-USER")
